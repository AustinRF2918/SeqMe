pub mod PartialSequencer
{
    use std::collections::HashMap;

    use sequencing::tonation::note::NoteCollections::RawNote;
    use sequencing::tonation::note::NoteGeneration::NoteBuilder;

    use instrumentation::interface::instrument::InstrumentWrapper;
    use instrumentation::interface::instrument::TestPlugin;
    use instrumentation::interface::instrument::Instrument;

    use sequencing::timing::timing::Beat::BeatValue;

    use schedule_recv::oneshot_ms;

    pub struct PartialSequencer<T: Instrument::PlayableInstrument>
    {
        local_beat_builder: BeatValue,
        local_note_builder: NoteBuilder,
        instrument: InstrumentWrapper::InstrumentWrapper<T>,
        note_hash: HashMap<u64, RawNote>
    }

    impl<T: Instrument::PlayableInstrument>PartialSequencer<T>
    {
        pub fn new(bpm: f32, instrument: T) -> PartialSequencer<T>
        {
            PartialSequencer
            {
                local_beat_builder: BeatValue::from_bpm(bpm),
                local_note_builder: NoteBuilder::new(),
                instrument: InstrumentWrapper::InstrumentWrapper::new(instrument),
                note_hash: HashMap::new(),
            }
        }

        pub fn internal_instrument(&mut self) -> &mut InstrumentWrapper::InstrumentWrapper<T>
        {
            &mut self.instrument
        }

        pub fn push_time_to_note(&mut self, bar: u64, bar_divisions: u64, note: RawNote)
        {
            self.note_hash.insert(self.local_beat_builder.u64_from_beats(bar, bar_divisions).unwrap(), note);

            let temp_timer_vec: Vec<schedule_recv::oneshot_ms> = Vec::new();

            for i in self.note_hash.keys()
            {

            }
        }

    }
}
